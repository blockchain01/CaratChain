
![CaratChain](https://github.com/blockchain01/CaratChain/blob/master/img/mmexport1531602574304.jpg?raw=true "CaratChain")

# 世界最大的區塊鏈鑽石交易平台

## 簡介：

 > 通過區塊鏈溯源技術及防偽技術，打造全世界最大的區塊鏈鑽石交易C2C平台。


## 目前鑽石交易行業面臨的問題：

 > 現時鑽石交易是純B2C交易，鑽石交易沒有第三方機構直接監管、鑑定求真。
 亦無法更大程度塑造鑽石價值，及開展`鑽石借貸`、`託管`、`維修`和`鑽石抵兌`等服務。

## 解決方案：

 > - 1. `Carat Chain`用區塊鏈技術保證鑽石的認證鑑定足夠真實，不易被篡改。
 
 > - 2. 鑽石的提取、製作以及成品的全過程，圴會記錄於區塊鏈的每個節點當中。
 
 > - 3. 通過區塊鏈技術放大產品價值，開展鑽石的全方位服務體系。
 
 > - 4. 引入第三方監管機構確保商家產品的真實性、同時引入徵信數據確保用戶有足夠購買能力！

 ## 技術應用：
 
 > Carat Chain會使用以太坊區塊鏈技術達成以上方案。
 
 ## 1. Carat Chain將會發行一種全新的`雙軌`代幣`CRT`：
 
 > - CRT共有兩版本，分別為：CRT-erc-20 及 CRT-erc-721。
 
 ## 2. 新一代的區塊鏈鑽石證書：
 
 > - CRT-erc-20，將會用於上架在各大舊式虛擬代幣交易所，方便用戶購買及交易Carat Chain的虛擬代幣CRT。

 > - CRT-erc-721，利用`erc-721虛擬代幣協議`的非同質性，將每個鑽石的提取、製作以及成品的所有數據，記錄於CRT-erc-721當中。
 
 > - 每一個CRT-erc-721都是可以交易的，但每一個CRT-erc-721的內容都不相同，我們可以將其理解為`新一代的區塊鏈鑽石證書`。
 
 > - 相比舊時代的鑽石證書，CRT-erc-721將會大大降低偽造、遺失、損毀等風險。加上CRT-erc-721可以隨時交易，保存性及流通性將會大大提升。
 
 > - Carat Chain會優先發行CRT-erc-20，再加上銷毀及兌換功能，用戶可各自交易CRT-erc-20及CRT-erc-721。
 
 > - 由於虛擬代幣協議不同，CRT-erc-20跟CRT-erc-721兩者是不能互換的。

 ## 3. 新一代的鑽石交易平台，CaratChain智能合約：
 
 > - 每當商家製作鑽石產品，他可以將整個過程的每一步記錄到CaratChain智能合約當中，由於區塊鏈技術的平等性及公開性，任何人都可以跟蹤製作鑽石產品的每一步。
 
 > - CaratChain智能合約會將每一個鑽石產品加上編號，方便跟蹤。而CaratChain亦會跟各第三方監管機構合作，平台將會使用最簡單介面，直接連結到三方監管機構。用戶將可以一站式購買、驗證、交易他們的鑽石產品。
 
 > - CaratChain智能合約沒有地區限制，商家可透過CaratChain跟世界各地的客戶交易，CaratChain智能合約亦可以成為用戶的鑽石交易平台，他們將可使用CaratChain跟親友交易自己的鑽石產品。
 
 ------
 
 ## 虛擬代幣CRT發行資料：
 
 > - 1. 代幣名稱  Carat Chain

 > - 2. 標記符號  CRT
 
 > - 3. 小數位     0
 
 > - 4. 總上限量  119 800 888
 
 > - 5. 免費獲取代幣上限     200 000CRT
 
 (4. + 5. = 120 000 000 (1.2億) )
 
 > - 6. 單個賬戶獲取免費代幣數量     100CRT
 
 ------
 
 ## 操作說明：
 
 ### 購買Carat Chain 代幣 CRT-erc-20
 
 > 1 . 請下載錢包程式imToken
 
 [imToken官方網站](https://token.im/download) | [IOS](https://itunes.apple.com/us/app/imtoken/id1153230571?ls=1&mt=8) | [Android](https://play.google.com/store/apps/details?id=org.consenlabs.token)
 
 > 2 . 開設好帳戶後請如圖示，加入CRT-erc-20的合約地址
 
 ![imTokenGetCRT1](https://github.com/blockchain01/CaratChain/blob/master/img/Screenshot_20180724-140713_imToken.jpg "imTokenGetCRT1")
 
 ![imTokenGetCRT2](https://github.com/blockchain01/CaratChain/blob/master/img/Screenshot_20180724-140719_imToken.jpg "imTokenGetCRT2")
  
 ![imTokenGetCRT3](https://github.com/blockchain01/CaratChain/blob/master/img/Screenshot_20180724-140724_imToken.jpg "imTokenGetCRT3")
 
 > 3 . 加入CRT-erc-20的合約地址後,即可自由交易及查看結餘。
 
 ### 免費獲取CRT
 
 > 1 . 請打開[網頁錢包MyEtherWallet](https://www.myetherwallet.com/#contracts)
 
 ![MyEtherWallet1](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-1.jpg "MyEtherWallet1")
 
 > 2 . 如圖示填寫合約地址及合約ABI | [複製ABI代碼](https://raw.githubusercontent.com/blockchain01/CaratChain/master/ABI/20ABI.code)
 
 ![MyEtherWallet2](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-2.jpg "MyEtherWallet2")
 
 > 3 . 這樣就打開了CRT-erc-20合約，選擇功能 FreeGetToken ,填寫您的錢包地址,即可獲得 100個CRT。
 
 
 ------
 
 ### 購買Carat Chain 代幣 CRT-erc-721
 
 #### 移動裝置：
 　
  ＊－－－－－－＊
  
 #### 其他方式：
 
 > 1 . 請打開[網頁錢包MyEtherWallet](https://www.myetherwallet.com/#contracts)
 
 ![MyEtherWallet1](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-1.jpg "MyEtherWallet1")
 
 > 2 . 如圖示填寫合約地址及合約ABI | [複製ABI代碼](https://raw.githubusercontent.com/blockchain01/CaratChain/master/ABI/721ABI.code)
 
 ![MyEtherWallet2](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-2.jpg "MyEtherWallet2")
 
 > 3 . 這樣就打開了CRT-erc-721合約，以下將介紹合約操作
 
  ![MyEtherWallet3](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-3.jpg "MyEtherWallet3")
  
 #### CRT-erc-721合約操作：
 
 > 3-1 . name = 本代幣全名稱 
 
 > 3-3 . totalSupply = CRT-erc-721的已經生產量
 
 > 3-4 . decimals = 小數位
 
 ### 3-5 . TokenDetails = 每一個CRT-erc-721的獨立數據
 
   > TotalSupply = CRT-erc-721的已經生產量
   
   > NowTokenId = 正在查看的代幣的id
   
   > NowTokenIndex = 這個代幣的數據網址
   
   > ThisTokenBuyPrice = 這個代幣的購買價格
   
   > ThisTokenHoldings = 這個代幣的持有人地址

  ![MyEtherWallet5](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-5.jpg "MyEtherWallet5")
   
 > 3-6 . burn = 銷毀代幣，限管理者使用，`_Id`填寫代幣的id，後請按 `寫入` / `WRITE`。
 
 > 3-8 . balanceOf = 帳戶持有的代幣餘額
 
 ### 3-9 . MyBuyRecord = 帳戶持有代幣的記錄

   > MyAddress = 填寫需要查詢的地址
   
   > MyTokenNumber = 填寫這地址購買次數號 *(次數號不是代幣ID號)
   
   > MybalanceOf = 帳戶持有的代幣餘額
   
   > NowTokenNumber = 正在查看的次數號
   
   > ThisTokenId = 這個次數號的代幣ID
 
 > 3-10 . owner = 本合約的管理者 *(購買CRT-erc-721代幣的費用將會存入此地址)
 
 > 3-11 . symbol = 本代幣簡稱 *(顯示於其他錢包程式)
 
 > 3-12 . Price = 購買CRT-erc-721代幣的費用 *(用`[Wei](https://converter.murkin.me/)`計算)
 
 ### 3-13 . making721 = 購買CRT-erc-721代幣：
 
   > index位置填寫代幣的數據網址，填寫後請按 `寫入` / `WRITE`
  
   > 要發送的數量...，在址填寫購買CRT-erc-721的費用 *(用`[以太幣](https://converter.murkin.me/)`計算)

  ![MyEtherWallet4](https://github.com/blockchain01/CaratChain/blob/master/img/%E6%9C%AA%E5%91%BD%E5%90%8D-4.jpg "MyEtherWallet4")
   

 ### 3-14 . transfer = 轉帳CRT-erc-721代幣
 
   > to = 填寫收取代幣的地址
   
   > Id = 填寫CRT-erc-721代幣的id
   
 > 3-17 . ChangeOwner = 轉換本合約的管理者，限管理者使用
 
 > 3-18 . ChangePrice = 修改購買CRT-erc-721代幣的費用，限管理者使用 *(用`[Szabo](https://converter.murkin.me/)`計算)(必須大於0)
  


 > 這幾個為連接Dapp用，管理者跟客戶都不需亦不能使用
 
     3-2 . approve | 3-7 . PublicTokenId | 3-15 . approveAndCall | 3-16 . allowance

  ------
  
  
 ## solidity原始代碼：
  
 ### CaratChainERC-20Token.sol
 
```

// 0x4d431a9871527ea30f0d99ef85d9561c64f51999


//版本聲明
pragma solidity ^0.4.24;

//外部使用受權
interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }


/////////////////////////////////////////////////////////////////設定合約持有人
contract SetOwner{ 
//合約持有人地址
    address public owner;

    function SetOwner() { 
//初始設定合約持有人  
        owner = msg.sender;
    }
}


/////////////////////////////////////////////////////////////////////////規則
contract BasicRules is SetOwner{

//驗證持有人,不是持有人則消耗GAS但取消所有動作
 modifier JustOwner() {assert(msg.sender == owner);  _;}
    
//新Owner不能是0,是0則取消所有動作
 modifier AddRrule(address _T) {require(address(0x0) != _T);  _;}
 
}



/////////////////////////////////////////////////////////////持有人修改合約資料
contract Admin is BasicRules {

//修改-合約持有人 
function ChangeOwner(address NewOwner) 
//新Owner不能是0
JustOwner AddRrule(NewOwner) public
returns (bool success){
//Owner=新Owner
owner = NewOwner;
return true; //成功通知
}


}




//合約開始
contract caratchainTokenERC20 is Admin {
    

///////////////////////////////////////////////////////////////////////// event

//轉帳時通知區塊
    event Transfer(address indexed from, address indexed to, uint256 value);
    
//受權時通知區塊
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);

//燒毀時通知區塊
    event Burn(address indexed from, uint256 value);
    
    
////////////////////////////////////////////////////////////////////////基本資料


//名,符號,小數,總量
    string public name = "Carat Chain";
    string public symbol = "CRT" ;
    uint8 public decimals = 0;
    uint256 public totalSupply = 119800000;
    
    
// 免費代幣用資料
   uint public FreeGetimit = 200000;   // 免費代幣上限
   uint public FreeGetVol = 100; // 單個賬戶獲取代幣數量
   uint public FreeGetped = 0; // 已派發免費代幣数量

////////////////////////////////////////////////////////////////////////個人資料

//戶口
   mapping (address => uint256) public balanceOf;

//已接受免費代幣的戶口
   mapping(address => bool) public priorityClient;
   
//受權額度  
    mapping (address => mapping (address => uint256)) public allowance;

////////////////////////////////////////////////////////////////////////合約功能



//合約初始化
    function caratchainTokenERC20() public {
        //初始發代幣全數給發行者
        balanceOf[msg.sender] = totalSupply;     
        //成為已接受免費獲取的戶口
        priorityClient[msg.sender] = true;
    }


//免費獲取代幣
  function FreeGetToken(address client) public payable {
    //入帳給owner  
    owner.transfer(msg.value);
    //驗證:未接受免費代幣||免費代幣未派完,不符則取消所有動作
    require(priorityClient[client] != true && FreeGetped < FreeGetimit);
    //成為已接受免費獲取的戶口
        priorityClient[client] = true;
    //已派發免費代幣数量+單個戶口免費獲取代幣數量
        FreeGetped += FreeGetVol;
    //代幣發行量+單個戶口免費獲取代幣數量
        totalSupply += FreeGetVol;
    // 戶口+單個戶口免費獲取代幣數量   
        balanceOf[client] += FreeGetVol;
  }



//轉帳
    function transfer(
        address _to,      //收帳人
        uint256 _value    //轉帳額
    ) public returns (bool success) {
//轉帳時的數據進入內部功能
        _transfer(msg.sender, _to, _value);
        return true;      //成功通知
    }
    

    
//銷毀TOKEN
    function burn(uint256 _value) public returns (bool success) {
//銷毀量少於戶口現有額
        require(balanceOf[msg.sender] >= _value); 
//在我的戶口中銷毀
        balanceOf[msg.sender] -= _value;  
//在總量中減少
        totalSupply -= _value; 
//燒毀時通知區塊
        emit Burn(msg.sender, _value);
        return true;  //成功通知
    }
    

    
//受權額度給其他人
    function approve(
        address _spender, //被受權者戶口
        uint256 _value    //受權額
    ) public
        returns (bool success) {
        allowance[msg.sender][_spender] = _value;  //記錄受權額
        emit Approval(msg.sender, _spender, _value);  //受權時通知區塊
        return true;   //成功通知
    }



//受權額度轉帳
    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {
//轉帳額少於受權額度
        require(_value <= allowance[_from][msg.sender]);
//受權轉帳額度減轉帳額
        allowance[_from][msg.sender] -= _value;
//轉帳時的數據進入內部功能
        _transfer(_from, _to, _value);
        return true;     //成功通知
    }
    
    
//在其他DAPP顯示
    function approveAndCall(
        address _spender,  //被受權者戶口
        uint256 _value,    //受權額
        bytes _extraData   //受權者留言
    ) public
        returns (bool success) {
//被受權者戶口可在其他DAPP使用
        tokenRecipient spender = tokenRecipient(_spender);
//如果有被受權
        if (approve(_spender, _value)) {
//將資料記錄在被受權者戶口(受權者'我',受權額,本合約地址,受權者留言)
            spender.receiveApproval(msg.sender, _value, this, _extraData);
            return true; //成功通知
        }
    }


////////////////////////////////////////////////////////////////////////內部功能


//轉帳時的內部功能
    function _transfer(address _from, address _to, uint _value) internal {
//防止轉到地址0
    require(_to != address(0x0));
//轉帳額少於戶口現有額
        require(balanceOf[_from] >= _value);
//收帳後必須大於收帳前
        require(balanceOf[_to] + _value >= balanceOf[_to]);
// 發送者戶口+收帳戶口額量,用於比較結果
        uint previousBalances = balanceOf[_from] + balanceOf[_to];
// 發送者戶減少發送量
        balanceOf[_from] -= _value;
// 收帳戶戶堵增加發送量
        balanceOf[_to] += _value;
// 轉帳時通知區塊    
        emit Transfer(_from, _to, _value);
//轉帳完成比較previousBalances,如不同則消耗GAS但取消所有轉帳動作
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }



}

```

 ------
 
 
  ### CaratChain-Rules.sol
  
  ```
  
  //版本聲明
pragma solidity ^0.4.24;



/////////////////////////////////////////////////////////////////設定合約持有人
contract SetOwner{ 
//合約持有人地址
    address public owner;
//購買721價格 以SZABO計算,1000000SZABO=1Ether  
    uint public Price = 3000 szabo; 


  
    function SetOwner() { 
//初始發設定合約持有人  
        owner = msg.sender;
        
        
    }
}


/////////////////////////////////////////////////////////////////////////規則
contract BasicRules is SetOwner{

//驗證持有人,不是持有人則消耗GAS但取消所有動作
 modifier JustOwner() {assert(msg.sender == owner);  _;}
    
//新Owner不能是0,是0則取消所有動作
 modifier AddRrule(address _T) {require(address(0x0) != _T);  _;}
 
//新匯率必須大於0||少於0則取消所有動作
 modifier PriceRrule(uint _E) {require(0 < _E);  _;}
}



/////////////////////////////////////////////////////////////持有人修改合約資料
contract Admin is BasicRules {


//修改-購買721價格 以SZABO計算,1000000SZABO=1Ether     
function ChangePrice(uint InputPrice) 
//驗證持有人//價格必須大於0
JustOwner PriceRrule(InputPrice) public
returns (bool success){
//價格=新價格 以SZABO計算,1000000SZABO=1Ether    
Price = (InputPrice * 1 szabo);
return true; //成功通知
}
    





//修改-合約持有人 
function ChangeOwner(address NewOwner) 
//新Owner不能是0
JustOwner AddRrule(NewOwner) public
returns (bool success){
//Owner=新Owner
owner = NewOwner;
return true; //成功通知
}



    
}

  ```
 
 ------
 
   ### CaratChainERC-721Token.sol
  
  ```

pragma solidity ^0.4.24;



import "./CaratChain-Rules.sol";  


//外部使用受權
interface tokenRecipient { function receiveApproval(address _from, uint256 _Id, address _token, bytes _extraData) external; }




//本合約
contract caratchainTokenERC721 is Admin {



///////////////////////////////////////////////////////////////////////// event

//轉帳時通知區塊
    event Transfer(address indexed from, address indexed to, uint256 id);
    
//受權時通知區塊
    event Approval(address indexed _owner, address indexed _spender, uint256 id);

//燒毀時通知區塊
    event Burn(address indexed from, uint256 id);
    
////////////////////////////////////////////////////////////////////////基本資料

//名,符號,小數,總量
    string public name = "Carat Chain721";
    string public symbol = "CRT721";
    uint8 public decimals = 0;
    uint256 public totalSupply;


//公眾查詢用TokenId
      uint256 public PublicTokenId;
mapping(uint => string)    TokenIdindex;      /* 獨立網址 */
mapping(uint => uint)   TokenIdBuyPrice;      /* 購買費用 */
mapping(uint => address)       Holdings;      /* 持有者 */


//驗證代幣持有者,不是代幣持有者則取消所有動作
 modifier JustHoldings(uint _Id,address _A) {require(msg.sender == Holdings[_Id]);  _;}
 
 
////////////////////////////////////////////////////////////////////////個人資料

//戶口
    mapping (address => uint256) public balanceOf;


//受權額度  
    mapping (address => mapping (address => uint256)) public allowance;



//我的購買記錄
  mapping(address => TokenData) MyList;
  
  
  
//購買記錄的內容
   TokenData MyTokenData; 
  struct  TokenData{  
        uint            MyToken;      /* 購買/持有次數 */
mapping(uint => uint)   TokenId;       /* 此編號代表的721代幣 */
    }



 

//////////////////////////////////////////////////////////////////在其他DAPP顯示

//受權額度給其他人
    function approve(
        address _spender, //被受權者戶口
        uint256 _Id    //受權額
    ) JustHoldings(_Id,msg.sender) public
        returns (bool success) {
        allowance[msg.sender][_spender] = 1;  //記錄受權額
        emit Approval(msg.sender, _Id, _spender);  //受權時通知區塊
        return true;   //成功通知
    }


//在其他DAPP顯示
    function approveAndCall(
        address _spender,  //被受權者戶口
        uint256 _Id,    //受權額
        bytes _extraData   //受權者留言
    ) JustHoldings(_Id,msg.sender) public
        returns (bool success) {
//被受權者戶口可在其他DAPP使用
        tokenRecipient spender = tokenRecipient(_spender);
//如果有被受權
        if (approve(_spender, _Id)) {
//將資料記錄在被受權者戶口(受權者'我',_Id,本合約地址,受權者留言)
            spender.receiveApproval(msg.sender, _Id, this, _extraData);
            return true; //成功通知
        }
    }


////////////////////////////////////////////////////////////////////////合約功能




//購買721代幣
  function making721(string index) external payable{
    //入帳給owner  
    owner.transfer(msg.value);
    //驗證價格  
    require(msg.value > Price || msg.value == Price);  
    //進入內部功能-新增代幣
    NewToken(msg.sender,index,msg.value);
  }




 
//轉帳
    function transfer(
        address _to,      //收帳人
        uint256 _Id    //轉帳額
    ) JustHoldings(_Id,msg.sender) AddRrule(_to) public returns (bool success) {
//轉帳時的數據進入內部功能
        _transfer(msg.sender, _to, _Id);
        return true;      //成功通知
    }
    









//受權額度轉帳
//    function transferFrom(address _from, address _to, uint256 _Id) JustHoldings(_Id,msg.sender)
//    public returns (bool success) {
//轉帳額少於受權額度
//        require(1 <= allowance[_from][msg.sender]);
//受權轉帳額度減轉帳額
//        allowance[_from][msg.sender] -= 1;
//轉帳時的數據進入內部功能
//        _transfer(_from, _to, _Id);
//        return true;     //成功通知
//    }


//銷毀TOKEN
    function burn(uint256 _Id) JustOwner JustHoldings(_Id,msg.sender) 
    public returns (bool success) {
//銷毀量少於戶口現有額
        require(balanceOf[msg.sender] >= 1); 
//在我的戶口中銷毀
        balanceOf[msg.sender] -= 1;  
//在總量中減少
        totalSupply -= 1; 
//燒毀時通知區塊
        emit Burn(msg.sender, _Id);
        return true;  //成功通知
    }
    





 
////////////////////////////////////////////////////////////////////////內部功能

//購買721代幣內部功能
  function NewToken(address _A,string _I,uint _V) private{
    //總量+1
    totalSupply++;
    //戶口+1
    balanceOf[_A]++;
    /* 我的購買記錄+1 */
    MyList[_A].MyToken++;
    //721代幣編號+1
    PublicTokenId++;
    /* 我的購買記錄=721代幣編號=現在的總量 */
    MyList[_A].TokenId[MyList[_A].MyToken] = totalSupply;
    //獨立網址
    TokenIdindex[PublicTokenId] = _I;
    //購買費用
    TokenIdBuyPrice[PublicTokenId] = _V;
    //持有者
    Holdings[PublicTokId] = _A;
  }
 


//轉帳時的內部功能
    function _transfer(address _from, address _to, uint _Id) internal {
//轉帳額少於戶口現有額
        require(balanceOf[_from] >= 1);
//收帳後必須大於收帳前
        require(balanceOf[_to] + 1 >= balanceOf[_to]);
// 發送者戶口+收帳戶口額量,用於比較結果
        uint previsBalances = balanceOf[_from] + balanceOf[_to];
// 發送者戶減少發送量
        balanceOf[_from] -= 1;
// 收帳戶戶堵增加發送量
        balanceOf[_to] += 1;
//轉換代幣持有者
        Holdings[_Id] = _to;
/* _to的購買記錄+1 */
        MyList[_to].MyToken++;    
/* 我的購買記錄=721代幣編號=現在的總量 */
        MyList[_to].TokenId[MyList[_to].MyToken] = _Id;    
    
// 轉帳時通知區塊    
        emit Transfer(_from, _to, _Id);
//轉帳完成比較previousBalances,如不同則消耗GAS但取消所有轉帳動作
        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);
    }
    





////////////////////////////////////////////////////////////////////////call功能

   //查看公眾TokenId
  function TokenDetails
  //我的帳戶,721代幣的Id
  (uint InputTokenId) 
  public view returns
  (uint256 TotalSupply,uint NowTokenId,string NowTokenIndex,uint ThisTokenBuyPrice,address ThisTokenHoldings){
      return(
            totalSupply,
            InputTokenId,
            TokenIdindex[InputTokenId],
            TokenIdBuyPrice[InputTokenId],
            Holdings[InputTokenId] 
            );
  }

 


  //查看我的購買記錄
  function MyBuyRecord
  //我的帳戶,購買編號
  (address MyAddress,uint MyTokenNumber) 
  public view returns
  //我的帳戶,購買編號,721代幣的Id
  (uint256 MybalanceOf,uint NowTokenNumber,uint ThisTokenId){
  //如不輸入購買編號,則顯示最新記錄
      if (MyTokenNumber == 0){
        return(
            balanceOf[MyAddress],
            MyList[MyAddress].MyToken,
            MyList[MyAddress].TokenId[MyList[MyAddress].MyToken]
            );
      }
      return(
            balanceOf[MyAddress],
            MyTokenNumber,
            MyList[MyAddress].TokenId[MyTokenNumber]
            );
  }



}

  ```
  
  
  
